"""
File: sensor.py
Description: This module defines SensorEntity classes for the Green Shift Home Assistant component.
It includes:
- HardwareSensorsSensor: A virtual sensor that aggregates all discovered hardware sensors by category, providing their current values and area information as attributes.
- ResearchPhaseSensor: A sensor that indicates the current research phase (baseline or active) and tracks the number of days in each phase.
- EnergyBaselineSensor: A sensor that provides the learned energy baseline consumption from the agent, allowing users to see the target they are working against.
- CurrentConsumptionSensor: A sensor that shows the current total power consumption as collected by the DataCollector.
- CurrentCostConsumptionSensor: A sensor that calculates the current cost per hour based on the current consumption and user-defined electricity price.
- DailyCostConsumptionSensor: A sensor that calculates the total cost accumulated for the current day based on the daily energy consumption and electricity price.
- DailyCO2EstimateSensor: A sensor that estimates the daily CO2 emissions based on the daily energy consumption and a fixed carbon intensity factor.
- SavingsAccumulatedSensor: A sensor that calculates the accumulated savings in EUR based on the difference between the baseline and current consumption over time.
- CO2SavedSensor: A sensor that estimates the amount of CO2 saved based on the energy savings compared to the baseline.
- TasksCompletedSensor: A sensor that counts the number of completed tasks in a rolling 30-day window.
- WeeklyChallengeSensor: A sensor that tracks the user's progress towards a weekly energy reduction challenge.
- BehaviourIndexSensor: A sensor that calculates a user behaviour index based on engagement and energy-saving actions.
- FatigueIndexSensor: A sensor that estimates user fatigue based on the frequency of notifications and time of day.
- DailyTasksSensor: A sensor that counts the number of tasks completed today.
- ActiveNotificationsSensor: A sensor that lists the currently active notifications generated by the AI agent.
These sensors provide valuable insights into the user's energy consumption patterns, the effectiveness of the AI agent's interventions and the overall progress towards energy-saving goals. They are designed to be updated in real-time as new data is collected and as the agent learns from user interactions.
"""

import logging
from datetime import datetime, timezone
from homeassistant.components.sensor import SensorEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.dispatcher import async_dispatcher_connect

from .const import CO2_FACTOR, DOMAIN, GS_UPDATE_SIGNAL, GS_AI_UPDATE_SIGNAL, BASELINE_DAYS, UPDATE_INTERVAL_SECONDS, PHASE_BASELINE
from .helpers import get_normalized_value, get_entity_area, get_environmental_impact

_LOGGER = logging.getLogger(__name__)


async def async_setup_entry(
    hass: HomeAssistant,
    config_entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """
    Setup of virtual sensors.
    
    Args:
        hass (HomeAssistant): The Home Assistant instance
        config_entry (ConfigEntry): The configuration entry for this integration
        async_add_entities (AddEntitiesCallback): Callback to add entities to Home Assistant
    """
    agent = hass.data[DOMAIN]["agent"]
    collector = hass.data[DOMAIN]["collector"]
    storage = hass.data[DOMAIN]["storage"]
    discovered_sensors = hass.data[DOMAIN]["discovered_sensors"]

    sensors = [
        HardwareSensorsSensor(hass, discovered_sensors, config_entry),
        ResearchPhaseSensor(agent),
        EnergyBaselineSensor(agent),
        CurrentConsumptionSensor(collector),
        CurrentCostConsumptionSensor(hass, collector),
        DailyCostConsumptionSensor(hass, collector),
        DailyCO2EstimateSensor(hass, collector),
        SavingsAccumulatedSensor(agent, collector),
        CO2SavedSensor(agent, collector),
        TasksCompletedSensor(storage),
        WeeklyChallengeSensor(agent),
        BehaviourIndexSensor(agent),
        FatigueIndexSensor(agent),
        DailyTasksSensor(storage),
        ActiveNotificationsSensor(agent)
    ]

    async_add_entities(sensors)


class GreenShiftBaseSensor(SensorEntity):
    """Base class to handle updates."""
    _attr_should_poll = False
    _attr_has_entity_name = True

    async def async_added_to_hass(self):
        """Register the listener when the entity is added to HA."""
        await super().async_added_to_hass()
        self.async_on_remove(
            async_dispatcher_connect(
                self.hass,
                GS_UPDATE_SIGNAL,
                self._update_callback
            )
        )

        # Perform an initial update if the sensor has an async update method
        self._update_callback()

    @callback
    def _update_callback(self):
        """Force the dashboard to update when the signal is received."""
        if hasattr(self, "_async_update_state"):
            # If the sensor defines an async update method (e.g., database call), run it in the background
            self.hass.async_create_task(self._async_update_and_write())
        else:
            # Standard synchronous update
            self.async_write_ha_state()

    async def _async_update_and_write(self):
        """Helper to await the update and then write state."""
        await self._async_update_state()
        self.async_write_ha_state()

class GreenShiftAISensor(SensorEntity):
    """Class to handle AI virtual sensor updates."""
    _attr_should_poll = False
    _attr_has_entity_name = True

    async def async_added_to_hass(self):
        """Register the listener when the entity is added to HA."""
        await super().async_added_to_hass()
        self.async_on_remove(
            async_dispatcher_connect(
                self.hass,
                GS_AI_UPDATE_SIGNAL,
                self._update_callback
            )
        )

        # Perform an initial update if the sensor has an async update method
        self._update_callback()

    @callback
    def _update_callback(self):
        """Force the dashboard to update when the signal is received."""
        if hasattr(self, "_async_update_state"):
            # If the sensor defines an async update method (e.g., database call), run it in the background
            self.hass.async_create_task(self._async_update_and_write())
        else:
            # Standard synchronous update
            self.async_write_ha_state()

    async def _async_update_and_write(self):
        """Helper to await the update and then write state."""
        await self._async_update_state()
        self.async_write_ha_state()

class HardwareSensorsSensor(GreenShiftBaseSensor):
    """Aggregates hardware sensors by category with live values."""

    def __init__(self, hass, discovered, config_entry):
        self.hass = hass
        self._discovered = discovered
        self.main_energy_sensor = config_entry.data.get("main_total_energy_sensor")
        self.main_power_sensor = config_entry.data.get("main_total_power_sensor")
        self._attr_translation_key = "hardware_sensors"
        self._attr_unique_id = f"{DOMAIN}_hardware_sensors"
        self._attr_icon = "mdi:database"

    @property
    def state(self):
        """The state can be a simple summary or count of sensors. For simplicity, we return 'ok' if any sensors are discovered."""
        return "ok"

    @property
    def extra_state_attributes(self):
        """Return a dictionary of all discovered sensors with their current values and area info."""
        data = {}
        to_exclude = {self.main_energy_sensor, self.main_power_sensor}

        for category, entities in self._discovered.items():
            data[category] = []

            for entity_id in entities:
                if entity_id in to_exclude:
                    continue

                state = self.hass.states.get(entity_id)
                if not state:
                    continue

                if category == "occupancy":
                    # Binary sensors don't have units and don't need float conversion
                    val = state.state
                    unit = None
                else:
                    # Numeric sensors (Power, Energy, Temp, Hum, Lux)
                    val, unit = get_normalized_value(state, category)

                if val is None:
                    continue

                area = get_entity_area(self.hass, entity_id) or "No Area"

                data[category].append({
                    "entity_id": entity_id,
                    "name": state.attributes.get("friendly_name", entity_id),
                    "value": val,
                    "unit": unit,
                    "area": area,
                })

        return data


class ResearchPhaseSensor(GreenShiftAISensor):
    """Sensor that indicates the current research phase."""

    def __init__(self, agent):
        self._agent = agent
        self._attr_translation_key = "research_phase"
        self._attr_unique_id = f"{DOMAIN}_research_phase"
        self._attr_icon = "mdi:flask"

    @property
    def state(self):
        """Return the current research phase."""
        return self._agent.phase

    @property
    def extra_state_attributes(self):
        """Return the number of days in the current phase and days remaining until baseline completion."""
        days_running = (datetime.now() - self._agent.start_date).days
        days_remaining = max(0, BASELINE_DAYS - days_running)
        return {
            "days_running": days_running,
            "days_remaining": days_remaining,
            "baseline_complete": days_running >= BASELINE_DAYS,
        }


class EnergyBaselineSensor(GreenShiftAISensor):
    """Sensor with the learned energy baseline from baseline phase."""

    def __init__(self, agent):
        self._agent = agent
        self._attr_translation_key = "energy_baseline"
        self._attr_unique_id = f"{DOMAIN}_baseline"
        self._attr_unit_of_measurement = "W"
        self._attr_device_class = "power"
        self._attr_icon = "mdi:chart-line"

    @property
    def unit_of_measurement(self):
        """Dynamic unit based on input_select."""
        return "W"

    @property
    def state(self):
        """Return the learned baseline consumption."""
        return round(self._agent.baseline_consumption, 2)


class CurrentConsumptionSensor(GreenShiftBaseSensor):
    """Sensor with the current consumption from DataCollector."""

    def __init__(self, collector):
        self._collector = collector
        self._attr_translation_key = "current_consumption"
        self._attr_unique_id = f"{DOMAIN}_current"
        self._attr_unit_of_measurement = "W"
        self._attr_device_class = "power"

    @property
    def unit_of_measurement(self):
        """Dynamic unit based on input_select."""
        return "W"

    @property
    def state(self):
        """Return the current total power consumption."""
        return round(self._collector.current_total_power, 3)


class CurrentCostConsumptionSensor(GreenShiftBaseSensor):
    """Sensor that calculates the current cost per hour based on consumption from DataCollector."""

    def __init__(self, hass, collector):
        self.hass = hass
        self._collector = collector
        self._attr_translation_key = "current_cost"
        self._attr_unique_id = f"{DOMAIN}_current_cost"
        self._attr_unit_of_measurement = "EUR/h"
        self._attr_icon = "mdi:cash-clock"

    @property
    def unit_of_measurement(self):
        """Dynamic unit based on input_select."""
        currency_state = self.hass.states.get("input_select.currency")

        return f"{currency_state.state}/h" if currency_state else "EUR/h" # Default to EUR/h if the input_select is missing

    @property
    def state(self):
        """Calculate the current cost per hour based on the current power consumption and electricity price."""
        # Get electricity price from input_number (default to 0.25 if unavailable)
        price_state = self.hass.states.get("input_number.electricity_price")
        try:
            price_per_kwh = float(price_state.state) if price_state else 0.25
        except (ValueError, TypeError):
            price_per_kwh = 0.25

        power_kw = self._collector.current_total_power / 1000.0
        cost_hourly = power_kw * price_per_kwh

        return round(cost_hourly, 3)

    @property
    def extra_state_attributes(self):
        """Return the current load, applied price per kWh and currency."""
        price_state = self.hass.states.get("input_number.electricity_price")
        currency_state = self.hass.states.get("input_select.currency")
        return {
            "current_load": round(self._collector.current_total_power, 3),
            "applied_price_per_kwh": price_state.state if price_state else "0.25 (default)",
            "currency": currency_state.state if currency_state else "EUR"
        }


class DailyCostConsumptionSensor(GreenShiftBaseSensor):
    """Sensor that calculates the daily cost based on consumption from DataCollector."""

    def __init__(self, hass, collector):
        self.hass = hass
        self._collector = collector
        self._attr_translation_key = "daily_cost"
        self._attr_unique_id = f"{DOMAIN}_daily_cost"
        self._attr_unit_of_measurement = "EUR"
        self._attr_icon = "mdi:cash-multiple"

    @property
    def unit_of_measurement(self):
        """Dynamic unit based on input_select."""
        currency_state = self.hass.states.get("input_select.currency")

        return f"{currency_state.state}" if currency_state else "EUR" # Default to EUR if the input_select is missing

    @property
    def state(self):
        """Calculate the total cost accumulated for the current day based on the daily energy consumption and electricity price."""
        # Price Logic
        price_state = self.hass.states.get("input_number.electricity_price")
        try:
            price_per_kwh = float(price_state.state) if price_state else 0.25
        except (ValueError, TypeError):
            price_per_kwh = 0.25

        # Get accurate daily kWh from the Odometer logic
        daily_kwh = self._collector.current_daily_energy

        # Calculate Cost
        cost = daily_kwh * price_per_kwh

        return round(cost, 2)

    @property
    def extra_state_attributes(self):
        """Return the daily kWh accumulated, applied price per kWh and currency."""
        price_state = self.hass.states.get("input_number.electricity_price")
        currency_state = self.hass.states.get("input_select.currency")
        return {
            "daily_kwh_accumulated": round(self._collector.current_daily_energy, 3),
            "applied_price": price_state.state if price_state else "0.25",
            "currency": currency_state.state if currency_state else "EUR"
        }


class DailyCO2EstimateSensor(GreenShiftBaseSensor):
    """Sensor that estimates daily CO2 emissions based on consumption from DataCollector."""

    def __init__(self, hass, collector):
        self.hass = hass
        self._collector = collector
        self._attr_translation_key = "daily_co2"
        self._attr_unique_id = f"{DOMAIN}_daily_co2"
        self._attr_unit_of_measurement = "kg"
        self._attr_icon = "mdi:leaf-circle"

    @property
    def unit_of_measurement(self):
        """Dynamic unit based on input_select."""
        return "kg"

    @property
    def state(self):
        """Calculate the daily CO2 emissions based on the daily energy consumption and a fixed carbon intensity factor."""
        co2_factor_portugal = CO2_FACTOR # kg/kWh as of early 2026

        # Get accurate daily kWh from the Odometer logic
        daily_kwh = self._collector.current_daily_energy

        # Calculate CO2 Emissions (daily_kwh * kg/kWh)
        co2_emissions = daily_kwh * co2_factor_portugal

        return round(co2_emissions, 2)

    @property
    def extra_state_attributes(self):
        """Return the daily kWh accumulated and the applied CO2 factor."""
        return {
            "daily_kwh_accumulated": round(self._collector.current_daily_energy, 3),
            "co2_factor": CO2_FACTOR,
        }


class SavingsAccumulatedSensor(GreenShiftAISensor):
    """Sensor with the accumulated savings in EUR."""

    def __init__(self, agent, collector):
        self._agent = agent
        self._collector = collector
        self._attr_translation_key = "savings_accumulated"
        self._attr_unique_id = f"{DOMAIN}_savings"
        self._attr_icon = "mdi:cash-check"
        self._attr_native_value = 0
        self._attr_extra_state_attributes = {}

    @property
    def unit_of_measurement(self):
        """Dynamic unit based on input_select.currency."""
        currency_state = self.hass.states.get("input_select.currency")
        return currency_state.state if currency_state else "EUR"

    @property
    def extra_state_attributes(self):
        """Return calculation details."""
        return self._attr_extra_state_attributes

    async def _async_update_state(self):
        """Fetch data asynchronously and calculate state."""
        # Only calculate savings during active phase, using data from when it started
        active_since = getattr(self._agent, 'active_since', None)
        if self._agent.phase == PHASE_BASELINE or active_since is None:
            self._attr_native_value = 0
            self._attr_extra_state_attributes = {
                "avg_power_w": 0,
                "baseline_consumption_w": round(self._agent.baseline_consumption, 2),
                "saving_watts": 0,
                "currency": self.unit_of_measurement,
                "note": "Waiting for active phase",
            }
            return

        # Limit history to only the active phase period (capped at DB retention of 14 days)
        hours_active = max(1, int((datetime.now() - active_since).total_seconds() / 3600))
        power_history_data = await self._collector.get_power_history(hours=hours_active)
        power_history = [power for timestamp, power in power_history_data]

        if len(power_history) < 10:
            self._attr_native_value = 0
            self._attr_extra_state_attributes = {
                "avg_power_w": 0,
                "baseline_consumption_w": round(self._agent.baseline_consumption, 2),
                "saving_watts": 0,
                "currency": self.unit_of_measurement,
            }
            return

        price_state = self.hass.states.get("input_number.electricity_price")
        try:
            price_per_kwh = float(price_state.state) if price_state else 0.25
        except (ValueError, TypeError):
            price_per_kwh = 0.25

        avg_consumption = sum(power_history) / len(power_history)
        saving_watts = self._agent.baseline_consumption - avg_consumption

        # Calculate hours covered by history based on update interval
        readings_per_hour = 3600 / UPDATE_INTERVAL_SECONDS
        hours = len(power_history) / readings_per_hour

        # Convert W to kW then to kWh
        saving_kwh = (saving_watts / 1000.0) * hours
        savings_total = saving_kwh * price_per_kwh

        self._attr_native_value = round(max(0, savings_total), 2)

        # Update attributes with calculation details
        self._attr_extra_state_attributes = {
            "avg_power_w": round(avg_consumption, 2),
            "baseline_consumption_w": round(self._agent.baseline_consumption, 2),
            "saving_watts": round(saving_watts, 2),
            "currency": self.unit_of_measurement,
            "price_per_kwh": price_per_kwh,
        }



class CO2SavedSensor(GreenShiftAISensor):
    """Sensor with the saved CO2 (kg)."""

    def __init__(self, agent, collector):
        self._agent = agent
        self._collector = collector
        self._attr_translation_key = "co2_saved"
        self._attr_unique_id = f"{DOMAIN}_co2"
        self._attr_unit_of_measurement = "kg"
        self._attr_icon = "mdi:leaf"
        self._attr_native_value = 0
        self._attr_extra_state_attributes = {}

    async def _async_update_state(self):
        """Fetch data asynchronously and calculate CO2 saved based on energy savings compared to the baseline."""
        # Only calculate CO2 savings during active phase, using data from when it started
        active_since = getattr(self._agent, 'active_since', None)
        if self._agent.phase == PHASE_BASELINE or active_since is None:
            self._attr_native_value = 0
            self._attr_extra_state_attributes = {}
            return

        hours_active = max(1, int((datetime.now() - active_since).total_seconds() / 3600))
        power_history_data = await self._collector.get_power_history(hours=hours_active)

        power_history = [power for timestamp, power in power_history_data]

        if len(power_history) < 10:
            self._attr_native_value = 0
            self._attr_extra_state_attributes = {"trees": 0, "flights": 0, "car_km": 0}
            return

        avg_consumption = sum(power_history) / len(power_history)
        saving_watts = self._agent.baseline_consumption - avg_consumption

        readings_per_hour = 3600 / UPDATE_INTERVAL_SECONDS
        hours = len(power_history) / readings_per_hour

        saving_kwh = (saving_watts * hours) / 1000

        impact = get_environmental_impact(max(0, saving_kwh))

        self._attr_native_value = impact["co2_kg"]

        self._attr_extra_state_attributes = {
            "trees": impact["trees"],
            "flights": impact["flights"],
            "car_km": impact["km"]
        }


class TasksCompletedSensor(GreenShiftAISensor):
    """Sensor with the number of completed tasks (30-day rolling window)."""

    def __init__(self, storage):
        self._storage = storage
        self._attr_translation_key = "tasks_completed"
        self._attr_unique_id = f"{DOMAIN}_tasks"
        self._attr_icon = "mdi:check-circle"
        self._completed_count = 0

    @property
    def state(self):
        """Return the number of completed tasks in the last 30 days."""
        return self._completed_count

    async def _async_update_state(self):
        """Fetch total completed task count from storage."""
        self._completed_count = await self._storage.get_total_completed_tasks_count()

class WeeklyChallengeSensor(GreenShiftAISensor):
    """Sensor for the weekly energy reduction challenge."""

    def __init__(self, agent):
        self._agent = agent
        self._attr_translation_key = "weekly_challenge"
        self._attr_unique_id = f"{DOMAIN}_weekly_challenge"
        self._attr_icon = "mdi:flag-checkered"
        self._attr_unit_of_measurement = "%"
        self._attr_native_value = 0
        self._attr_extra_state_attributes = {}

    def _get_target_percentage(self):
        """Get the current target percentage from input_number."""
        target_state = self.hass.states.get("input_number.energy_saving_target")
        try:
            return float(target_state.state) if target_state else 15.0
        except (ValueError, TypeError):
            return 15.0

    async def _async_update_state(self):
        """Fetch weekly challenge status from the agent and update state and attributes."""
        if self._agent.phase == PHASE_BASELINE:
            return

        current_target = self._get_target_percentage()

        challenge = await self._agent.get_weekly_challenge_status(target_percentage=current_target)

        self._attr_native_value = challenge.get("progress", 0)

        _LOGGER.debug(f"Weekly Challenge Update: Progress={self._attr_native_value}%, Details={challenge}")

        self._attr_extra_state_attributes = {
            "status": challenge.get("status", "pending"),
            "progress": self._attr_native_value,
            "current_avg_w": challenge.get("current_avg", 0),
            "target_avg_w": challenge.get("target_avg", 0),
            "baseline_w": challenge.get("baseline", 0),
            "goal": current_target,
            "week_start": challenge.get("week_start", None),
            "days_in_week": challenge.get("days_in_week", 0),
        }


class BehaviourIndexSensor(GreenShiftAISensor):
    """Sensor with the agent's behaviour index."""

    def __init__(self, agent):
        self._agent = agent
        self._attr_translation_key = "behaviour_index"
        self._attr_unique_id = f"{DOMAIN}_behaviour"
        self._attr_icon = "mdi:account-check"

    @property
    def state(self):
        """Return the current behaviour index, rounded to 2 decimals for better readability."""
        return round(self._agent.behaviour_index, 2)


class FatigueIndexSensor(GreenShiftAISensor):
    """Sensor with the agent's fatigue index."""

    def __init__(self, agent):
        self._agent = agent
        self._attr_translation_key = "fatigue_index"
        self._attr_unique_id = f"{DOMAIN}_fatigue"
        self._attr_icon = "mdi:alert-circle"

    @property
    def state(self):
        """Return the current fatigue index, rounded to 2 decimals for better readability."""
        return round(self._agent.fatigue_index, 2)


class DailyTasksSensor(GreenShiftAISensor):
    """Sensor showing daily tasks with verification status and difficulty feedback."""

    _attr_should_poll = False

    def __init__(self, storage):
        self._storage = storage
        self._attr_translation_key = "daily_tasks"
        self._attr_unique_id = f"{DOMAIN}_daily_tasks"
        self._attr_icon = "mdi:clipboard-check-outline"
        self._tasks = []

    async def async_added_to_hass(self):
        """Register the listener when the entity is added to HA."""
        await super().async_added_to_hass()
        self.async_on_remove(
            async_dispatcher_connect(self.hass, GS_AI_UPDATE_SIGNAL,self._update_callback)
        )
        # Initial load
        await self._async_update_state()

    @callback
    def _update_callback(self):
        """Force update when signal is received."""
        self.hass.async_create_task(self._async_update_and_write())

    async def _async_update_and_write(self):
        """Helper to await the update and then write state."""
        await self._async_update_state()
        self.async_write_ha_state()

    async def _async_update_state(self):
        """Fetch today's tasks from storage."""
        self._tasks = await self._storage.get_today_tasks()

    @property
    def state(self):
        """Return number of tasks."""
        return len(self._tasks)

    @property
    def extra_state_attributes(self):
        """Return task details with verification and feedback status."""
        if not self._tasks:
            return {
                "tasks": [],
                "completed_count": 0,
                "verified_count": 0,
                "total_count": 0
            }

        completed_count = sum(1 for t in self._tasks if t['completed'])
        verified_count = sum(1 for t in self._tasks if t['verified'])

        # Format tasks for display
        tasks_display = []
        for task in self._tasks:
            raw_target = task.get('target_value', 0)
            raw_baseline = task.get('baseline_value', 0)
            unit = task.get('target_unit', '')

            if unit == 'W':
                # Force Integer for Watts
                formatted_target = int(float(raw_target)) if raw_target is not None else 0
                formatted_baseline = int(float(raw_baseline)) if raw_baseline is not None else 0
            else:
                # Force 1 decimal for Temp/Other
                formatted_target = round(float(raw_target), 1) if raw_target is not None else 0.0
                formatted_baseline = round(float(raw_baseline), 1) if raw_baseline is not None else 0.0

            task_info = {
                'task_id': task['task_id'],
                'title': task['title'],
                'description': task['description'],
                'target_value': formatted_target,
                'target_unit': unit,
                'baseline_value': formatted_baseline,
                'difficulty_level': task['difficulty_level'],
                'completed': task['completed'],
                'verified': task['verified'],
                'user_feedback': task['user_feedback'],
                'area_name': task['area_name'],
            }

            # Add completion value if available
            if task['completion_value']:
                task_info['completion_value'] = task['completion_value']

            # Add status indicator
            if task['verified']:
                task_info['status'] = 'verified'
                task_info['status_emoji'] = 'âœ…'
            elif task['completed']:
                task_info['status'] = 'completed'
                task_info['status_emoji'] = 'â³'
            else:
                task_info['status'] = 'pending'
                task_info['status_emoji'] = 'ðŸŽ¯'

            # Add difficulty indicator
            difficulty_emojis = {1: 'â­', 2: 'â­â­', 3: 'â­â­â­', 4: 'â­â­â­â­', 5: 'â­â­â­â­â­'}
            task_info['difficulty_display'] = difficulty_emojis.get(task['difficulty_level'], 'â­â­â­')

            tasks_display.append(task_info)

        return {
            "tasks": tasks_display,
            "completed_count": completed_count,
            "verified_count": verified_count,
            "total_count": len(self._tasks),
        }

class ActiveNotificationsSensor(GreenShiftAISensor):
    """Sensor showing active notifications that need user feedback."""

    _attr_should_poll = False

    def __init__(self, agent):
        self._agent = agent
        self._attr_translation_key = "active_notifications"
        self._attr_unique_id = f"{DOMAIN}_active_notifications"
        self._attr_icon = "mdi:bell-ring"

    @property
    def state(self):
        """Return count of unresponded notifications."""
        unresponded = [n for n in self._agent.notification_history if not n.get("responded", False)]
        return len(unresponded)

    @property
    def extra_state_attributes(self):
        """Return notification details."""

        # Get all notifications from history
        all_notifications = []

        for notif in self._agent.notification_history:
            # Parse timestamp
            try:
                timestamp = datetime.fromisoformat(notif["timestamp"])
                time_ago = self._get_time_ago(timestamp)
            except:
                time_ago = "Unknown"

            notification_data = {
                "notification_id": notif["notification_id"],
                "action_type": notif["action_type"],
                "title": notif.get("title", "Energy Notification"),
                "message": notif.get("message", ""),
                "timestamp": notif["timestamp"],
                "time_ago": time_ago,
                "responded": notif.get("responded", False),
                "accepted": notif.get("accepted", None),
            }

            # Add status emoji
            if notif.get("responded"):
                if notif.get("accepted"):
                    notification_data["status"] = "Helpful"
                    notification_data["status_emoji"] = "âœ…"
                else:
                    notification_data["status"] = "Not useful"
                    notification_data["status_emoji"] = "âŒ"
            else:
                notification_data["status"] = "Pending"
                notification_data["status_emoji"] = "â³"

            all_notifications.append(notification_data)

        # Sort by timestamp (newest first)
        all_notifications.sort(key=lambda x: x["timestamp"], reverse=True)

        # Count statistics
        total = len(all_notifications)
        responded = sum(1 for n in all_notifications if n["responded"])
        accepted = sum(1 for n in all_notifications if n.get("accepted") == True)
        rejected = sum(1 for n in all_notifications if n.get("accepted") == False)
        pending = total - responded

        return {
            "notifications": all_notifications,
            "total_count": total,
            "pending_count": pending,
            "accepted_count": accepted,
            "rejected_count": rejected,
            "acceptance_rate": round((accepted / responded * 100) if responded > 0 else 0, 1),
        }

    def _get_time_ago(self, timestamp):
        """
        Convert timestamp to human-readable time ago.
        
        Args:
            timestamp (datetime): The timestamp to convert.

        Returns:
            str: A human-readable string representing how long ago the timestamp was.
        """
        now = datetime.now()

        # Handle timezone-aware vs naive datetimes
        if timestamp.tzinfo is not None and now.tzinfo is None:
            now = now.replace(tzinfo=timezone.utc)
        elif timestamp.tzinfo is None and now.tzinfo is not None:
            timestamp = timestamp.replace(tzinfo=now.tzinfo)

        diff = now - timestamp

        seconds = diff.total_seconds()

        if seconds < 60:
            return "Just now"
        elif seconds < 3600:
            minutes = int(seconds / 60)
            return f"{minutes}m ago"
        elif seconds < 86400:
            hours = int(seconds / 3600)
            return f"{hours}h ago"
        else:
            days = int(seconds / 86400)
            return f"{days}d ago"
